WELCOME TO MINIFY 2.0!

Minify is an HTTP content server. It compresses sources of content 
(usually files), combines the result and serves it with appropriate 
HTTP headers. These headers can allow clients to perform conditional 
GETs (serving content only when clients do not have a valid cache) 
or tell clients to cache the file until a given date/time. 
More info: http://code.google.com/p/minify/

INSTALLATION AND USAGE: http://code.google.com/p/minify/wiki/UserGuide

UNIT TESTING & EXAMPLES: http://code.google.com/p/minify/wiki/TestingMinify

MINIFY OVERVIEW 

Minify works with Minify_Source objects. These usually represent a file 
on disk, but a source can also be a string in memory or from a database. 
Sources with known "last modified" timestamps allow Minify to implement 
server-side caching and conditional GETs.

You configure Minify via a Minify_Controller object. The controller 
supplies the sources and default options to serve a request, 
determining how it's to be responded to. Several controllers are 
supplied with Minify, but it's also fairly easy to write your own. See
the files in /lib/Minify/Controller for examples.

To use an existing controller, you call Minify::serve(), passing it:
1. the name of your controller of choice (without the "Minify_Controller" 
   prefix) or a custom controller object subclassed from Minify_Controller_Base.
2. a combined array of controller and Minify options. Eg.: 

// serve a minified javascript file and tell clients to cache it for a 
// year 
Minify::serve('Files', array(
	'files' => array('/path/to/file1.js', '/path/to/file2.js')
	,'setExpires' => (time() + 86400 * 365)
));

The above creates an instance of Minify_Controller_Files, which creates 
source objects from the 'files' option, and supplies other default options. 

FILE ENCODINGS

Minify *should* work fine with files encoded in UTF-8 or other 8-bit 
encodings like ISO 8859/Windows-1252. Leading UTF-8 BOMs are stripped from
all sources to prevent duplication in output files.
